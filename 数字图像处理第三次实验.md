# 实验三 图像的集合变换
## 班级：计科2003 姓名：田沛骐 学号：2020014457

# 实验目的
几何变换对图像产生一定的变形，在许多领域有着广泛的应用。实验目的为掌握用的图像几何变换方法 及其实现，为相关应用打下一定的基础。
# 实验内容
1. 图像平移与处理
![[Pasted image 20221130135043.png]]
![[Pasted image 20221130140024.png]]
变换前
![[Pasted image 20221130132728.png]]
变换后 
平移
![[Pasted image 20221130132716.png]]
旋转
![[Pasted image 20221130133430.png]]



# 关键代码
**注：因为得出实验报告的软件使用了vim键位映射，为了避免麻烦，所以代码块中的注释为英语**
* 实验一代码采用函数指针数组组织，通过获取当前点的坐标进行计算，从而返回对应的操作映射数字，再通过对应的数字在函数指针数组中查找对应函数，进行映射。
```C++
#define POS 1
#define NEG -1
//size of the block in Q1
#define BLK_R_SZ 200
#define BLK_C_SZ 200
// where the block located
#define BLK_R_S 200
#define BLK_C_S 200
//DISCARD -> simply copy 
//Other elements in the enum corresponds to the operation in the question asked.
enum { DISCARD = 0, MIR_LR, BLUR, MIR_UD , IDENTITY };
void discard(int row, int col, Mat* src, Mat* dst);
void identity(int row, int col, Mat* src, Mat* dst);
void mir_LR(int row, int col, Mat* src, Mat* dst);
void blur(int row, int col, Mat* src, Mat* dst);
void mir_UD(int row, int col, Mat* src, Mat* dst);
typedef uint op;
void (*f[5])(int, int, Mat*, Mat*);
int checkpos(int, int, Mat);

```
定义范围 函数，函数指针数组。
```C++
Mat* Q1(Mat src) {
	uint rows = src.rows;
	uint cols = src.cols;
	uint row_range[] = { 300,510 };
	uint col_range[] = { 150,340 };
	Mat* dst = new Mat(src.size(), CV_8UC3);
	for (int row = 0; row < rows; row++)
	{
		for (int col = 0; col < cols; col++) {
			int op = checkpos(row, col,src);
			if(op == IDENTITY ||op == DISCARD || op == MIR_LR || op == MIR_UD || op == BLUR)
			f[op](row, col, &src, dst);
		}
	}
	return dst;
}
```
获取点对应的坐标，并且根据返回的值对该像素从函数指针数组中选择函数进行适当的操作。
```C++
void discard(int row, int col, Mat* src, Mat* dst)
{
	dst->at<Vec3b>(row, col)[0] = src->at<Vec3b>(row, col)[0];
	dst->at<Vec3b>(row, col)[1] = src->at<Vec3b>(row, col)[1];
	dst->at<Vec3b>(row, col)[2] = src->at<Vec3b>(row, col)[2];
}

```

```C++
void identity(int row, int col, Mat* src, Mat* dst)
{
	int c_row = row + BLK_R_S;
	int c_col = col + BLK_C_S;
	if (c_row >= src->rows || c_col >= src->cols)
		return;
	dst->at<Vec3b>(row, col)[0] = src->at<Vec3b>(c_row, c_col)[0];
	dst->at<Vec3b>(row, col)[1] = src->at<Vec3b>(c_row, c_col)[1];
	dst->at<Vec3b>(row, col)[2] = src->at<Vec3b>(c_row, c_col)[2];
}
```

```C++
void mir_LR(int row, int col, Mat* src, Mat* dst)
{
	int c_row = BLK_R_S +row;
	int c_col = (BLK_C_S+BLK_C_SZ) - (col - (src->cols-BLK_C_SZ));
	if (c_row >= src->rows || c_col >= src->cols)
		return;
	dst->at<Vec3b>(row, col)[0] = src->at<Vec3b>(c_row, c_col)[0];
	dst->at<Vec3b>(row, col)[1] = src->at<Vec3b>(c_row, c_col)[1];
	dst->at<Vec3b>(row, col)[2] = src->at<Vec3b>(c_row, c_col)[2];
}
```

```C++
int checkpos(int row, int col, Mat src)
{
	//block size is 300 * 300 for convenience.
	int b_row = src.rows;
	int b_col = src.cols;
	if (row <= BLK_C_SZ && col <= BLK_C_SZ)
		return IDENTITY;
	if (row <= BLK_R_SZ && col >= (b_col - BLK_C_SZ))
		return MIR_LR;
	if (row >= (b_row - BLK_R_SZ) && col <= BLK_C_SZ)
		return BLUR;
	if (row >= (b_row - BLK_R_SZ) && col >= (b_col - BLK_C_SZ))
		return MIR_UD;
	return DISCARD;
}
```
平滑函数在上次实验已经提交，上下镜像变换的代码与左右的类似，故不列出。

平移
```C++
Mat imageTranslation(Mat& srcImage) {

       int xs, xe, ys, ye;

       xs = 200; ys = 90; xe = 290; ye = 150;

       Mat tmp = srcImage;

       Mat tmp3 = srcImage;

       Mat tmp2;

       int w1, w2;

       int rows = srcImage.rows;  

       int cols = srcImage.cols; 

       resize(tmp, tmp2, cv::Size(cols / 2, rows / 2));

       for (int i = ys / 2; i < ye / 2; i++) {

              for (int j = xs / 2; j < xe / 2; j++) {
             int x = j - xs / 2;
             int y = i - ys / 2;
            if (x > 0 && y > 0 && x <= (xe - xs) / 2 && y <= (ye - ys) / 2)
{     
srcImage.ptr<cv::Vec3b>(y)[x] = tmp2.at<cv::Vec3b>(i, j);

     }
	 w1 = x;

              }

       }

       for (int i = ys; i < ye; i++) {

              for (int j = xs; j < xe; j++) {

                    /

                     int x = j - xs;

                     int y = i - ys;

                     

                     if (x > 0 && y > 0 && x <= xe && y <= ye)

                            tmp.at<cv::Vec3b>(i, j) = tmp3.at<cv::Vec3b>(i, j);

              }

       }

       resize(tmp, tmp2, cv::Size(cols, rows * 2 / 3));

       for (int i = ys * 2 / 3; i < ye * 2 / 3; i++) {

              for (int j = xs; j < xe; j++) {             
                     int x = j - xs + 10 + w1;

                     int y = i - ys * 2 / 3;// w1 

                 

                     if (x > 10 + w1 && y > 0 && x <= (xe - xs) + 10 + w1 && y <= (ye - ys) * 2 / 3)

                     {

                            srcImage.ptr<cv::Vec3b>(y)[x] = tmp2.at<cv::Vec3b>(i, j);

                     }

                     w2 = x;

              }

       }

   

       for (int i = ys; i < ye; i++) {

              for (int j = xs; j < xe; j++) {

               
                     int x = j - xs;

                     int y = i - ys;

                  

                     if (x > 0 && y > 0 && x <= xe && y <= ye)

                            tmp.at<cv::Vec3b>(i, j) = tmp3.at<cv::Vec3b>(i, j);

              }

       }

       resize(tmp, tmp2, cv::Size(cols * 5 / 4, rows * 7 / 5));

       for (int i = ys * 7 / 5; i < ye * 7 / 5; i++) {

              for (int j = xs * 5 / 4; j < xe * 5 / 4; j++) {
                     int x = j - xs * 5 / 4 + 10 + w2;
                     int y = i - ys * 7 / 5;

                     if (x > 10 + w2 && y > 0 && x <= (xe - xs) * 5 / 4 + 10 + w2 && y <= (ye - ys) * 7 / 5)

                     {

                            srcImage.ptr<cv::Vec3b>(y)[x] = tmp2.at<cv::Vec3b>(i, j);

                     }

              }

       }

       return srcImage;

}
```


旋转
```C++
Mat photoRotate(Mat img, float angle)

{

       Mat retMat = Mat::zeros(img.rows, img.cols, CV_8UC3);

       float anglePI = angle / 180;

       int xSm, ySm;

       for (int i = 0; i < retMat.rows; i++)

              for (int j = 0; j < retMat.cols; j++)

              {

                     xSm = (int)((i - retMat.rows / 2) * cos(anglePI) - (j - retMat.cols / 2) * sin(anglePI) + 0.5);

                     ySm = (int)((i - retMat.rows / 2) * sin(anglePI) + (j - retMat.cols / 2) * cos(anglePI) + 0.5);

                     xSm += img.rows / 2;

                     ySm += img.cols / 2;

                     if (xSm >= img.rows || ySm >= img.cols || xSm <= 0 || ySm <= 0) {

                            retMat.at<Vec3b>(i, j) = Vec3b(0, 0);

                     }

                     else {

                            retMat.at<Vec3b>(i, j) = img.at<Vec3b>(xSm, ySm);

                     }

              }

       return retMat;

}

```