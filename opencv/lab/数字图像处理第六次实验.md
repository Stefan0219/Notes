# 第六次实验
* 班级：计科2003
* 姓名：田沛骐
* 学号：2020014457
## 迭代法图像分割
![[Pasted image 20221209230058.png]]
![[Pasted image 20221209230838.png]]
												**迭代8次** 
处理结果
## 源代码
### 迭代法
思路：
1. 先获取初始权重：为图像灰度化后，最大灰度与最小灰度的均值。
2. 迭代，计算分割两个图像灰度值的均值，更新权重，直至两图像灰度均值差小于epsilon。
3. 根据最终的权重，对图像进行分割。
```C++
int getInitThresh(const cv::Mat image) {
	int row = image.rows;
	int col = image.cols;
	int biggest = 0;
	int smallest = 255;
	for (int i = 0; i < row; i++) {
		for (int j = 0; j < col; j++)
		{
			int temp = image.at<uchar>(i, j);
			if (temp > biggest)
				biggest = temp;
			if (temp < smallest)
				smallest = temp;
		}
	}
	return (biggest + smallest) / 2;
}
```

```C++
int getNewThresh(int oldThresh, const cv::Mat image) {
	int n_pix_p_above = 0;
	int n_pix_p_down = 0;
	int sum_above = 0;
	int sum_down = 0;
	int row = image.rows;
	int col = image.cols;
	for (int i = 0; i < row; i++) {
		for (int j = 0; j < col; j++) {
			int temp = image.at<uchar>(i, j);
			if (temp >= oldThresh) {
				n_pix_p_above++;
				sum_above += temp;
			}
			else {
				n_pix_p_down++;
				sum_down += temp;
			}
		}
	}
	return ((sum_above / n_pix_p_above) + (sum_down / n_pix_p_down)) / 2;
}
```
```C++
int getFinalThresh(const cv::Mat image) {
	int olderThresh = getInitThresh(image);
	int newThresh = getNewThresh(olderThresh, image);
	int epsilon = 1;
	int cnt = 0;
	while (abs(olderThresh - newThresh) > epsilon)
	{
		olderThresh = newThresh;
		newThresh = getNewThresh(newThresh, image);
		cnt++;
	}
	std::cout << "Iteration time: " << cnt << std::endl;
	return newThresh;
}
```

```C++
void show_split_iteration(const cv::Mat image, int thresh) {
	Mat one(image.size(), CV_8UC1);
	Mat two(image.size(), CV_8UC1);
	int row = one.rows;
	int col = one.cols;
	for (int i = 0; i < row; i++)
	{
		for (int j = 0; j < col; j++)
		{
			int temp = image.at<uchar>(i, j);
			if (temp >= thresh) {
				one.at<uchar>(i, j) = temp;
				two.at<uchar>(i, j) = 255;
			}
			else {
				two.at<uchar>(i, j) = temp;
				one.at<uchar>(i, j) = 0;
			}
		}
	}
	imshow("front", one);
	imshow("back", two);
}
```