# 第六次实验
* 班级：计科2003
* 姓名：田沛骐
* 学号：2020014457
## 迭代法图像分割
![[Pasted image 20221209230058.png]]
![[Pasted image 20221210120906.png]]
							**迭代8次,最终灰度权重为214** 
处理结果
## 大津二值化图像分割
![[Pasted image 20221210120438.png]]
![[Pasted image 20221210120450.png]]
权重为216
## sobel,canny,log,prewitt
sobel,prewitt在实验二中已经给出，所以不再展示
![[Pasted image 20221210122328.png]]
canny
![[Pasted image 20221210123334.png]]
log
## 源代码
### 迭代法
思路：
1. 先获取初始权重：为图像灰度化后，最大灰度与最小灰度的均值。
2. 迭代，计算分割两个图像灰度值的均值，更新权重，直至两图像灰度均值差小于epsilon。
3. 根据最终的权重，对图像进行分割。
```C++
int getInitThresh(const cv::Mat image) {
	int row = image.rows;
	int col = image.cols;
	int biggest = 0;
	int smallest = 255;
	for (int i = 0; i < row; i++) {
		for (int j = 0; j < col; j++)
		{
			int temp = image.at<uchar>(i, j);
			if (temp > biggest)
				biggest = temp;
			if (temp < smallest)
				smallest = temp;
		}
	}
	return (biggest + smallest) / 2;
}
```

```C++
int getNewThresh(int oldThresh, const cv::Mat image) {
	int n_pix_p_above = 0;
	int n_pix_p_down = 0;
	int sum_above = 0;
	int sum_down = 0;
	int row = image.rows;
	int col = image.cols;
	for (int i = 0; i < row; i++) {
		for (int j = 0; j < col; j++) {
			int temp = image.at<uchar>(i, j);
			if (temp >= oldThresh) {
				n_pix_p_above++;
				sum_above += temp;
			}
			else {
				n_pix_p_down++;
				sum_down += temp;
			}
		}
	}
	return ((sum_above / n_pix_p_above) + (sum_down / n_pix_p_down)) / 2;
}
```
```C++
int getFinalThresh(const cv::Mat image) {
	int olderThresh = getInitThresh(image);
	int newThresh = getNewThresh(olderThresh, image);
	int epsilon = 1;
	int cnt = 0;
	while (abs(olderThresh - newThresh) > epsilon)
	{
		olderThresh = newThresh;
		newThresh = getNewThresh(newThresh, image);
		cnt++;
	}
	std::cout << "Iteration time: " << cnt << std::endl;
	return newThresh;
}
```

```C++
void show_split_iteration(const cv::Mat image, int thresh) {
	Mat one(image.size(), CV_8UC1);
	Mat two(image.size(), CV_8UC1);
	int row = one.rows;
	int col = one.cols;
	for (int i = 0; i < row; i++)
	{
		for (int j = 0; j < col; j++)
		{
			int temp = image.at<uchar>(i, j);
			if (temp >= thresh) {
				one.at<uchar>(i, j) = temp;
				two.at<uchar>(i, j) = 255;
			}
			else {
				two.at<uchar>(i, j) = temp;
				one.at<uchar>(i, j) = 0;
			}
		}
	}
	imshow("front", one);
	imshow("back", two);
}
```
### 大津二值化
思路：找到使得类间方差最大的阈值。
```C++
cv::Mat Binarize_Otsu(cv::Mat gray) {
    int width = gray.cols;
    int height = gray.rows;

    double w0 = 0, w1 = 0;
    double m0 = 0, m1 = 0;
    double max_sb = 0, sb = 0;
    int th = 0;
    int val;

    for (int t = 0; t < 255; t++) {
        w0 = 0;
        w1 = 0;
        m0 = 0;
        m1 = 0;
        for (int y = 0; y < height; y++) {
            for (int x = 0; x < width; x++) {
                val = (int)(gray.at<uchar>(y, x));

                if (val < t) {
                    w0++;
                    m0 += val;
                }
                else {
                    w1++;
                    m1 += val;
                }
            }
        }

        m0 /= w0;
        m1 /= w1;
        w0 /= (height * width);
        w1 /= (height * width);
        sb = w0 * w1 * pow((m0 - m1), 2);

        if (sb > max_sb) {
            max_sb = sb;
            th = t;
        }
    }

    std::cout << "threshold:" << th << std::endl;

    cv::Mat out = cv::Mat::zeros(height, width, CV_8UC1);

    for (int y = 0; y < height; y++) {
        for (int x = 0; x < width; x++) {
            if (gray.at<uchar>(y, x) > th) {
                out.at<uchar>(y, x) = 255;
            }
            else {
                out.at<uchar>(y, x) = 0;
            }

        }
    }

    return out;
}
```
### canny
调用opencv库函数。
### LOG
```

```